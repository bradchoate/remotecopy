#!/usr/bin/perl

use strict;
use warnings;

use IO::Socket;
use Getopt::Long;
use IO::File;

my $proto_version = 1;

Getopt::Long::Configure("no_auto_abbrev");

my %options;
my $opts_ok = GetOptions( \%options, 'help|?|h', 'man', 'secret|s=s',
    'non-interactive|n' );

$options{secret} ||= '';

my $data;
if ( scalar(@ARGV) ) {
    $data = join( ' ', @ARGV );
}
else {
    local $/ = undef;
    $data = <STDIN>;
}

send_copy_data( $data, $options{secret} );

sub read_hello {
    my $sock = shift;

    my $line = <$sock>;
}

sub send_copy_data {
    my ( $data, $secret ) = @_;

    my $sock = IO::Socket::INET->new(
        Proto     => 'tcp',
        PeerAddr  => '127.0.0.1',
        PeerPort  => 12345,
        ReuseAddr => 1,
    ) or die "Unable to connect: $!.\n";

    read_hello($sock);

    # send authentication
    printf $sock "%d:%s", $proto_version, $secret;

    my $line = <$sock>;
    if ( $line =~ /SUCCESS/ ) {

        # auth successful, send copy data
        print $sock $data;
    }
    elsif ( $line =~ /FAILURE AUTH/ ) {
        if ( $options{'non-interactive'} ) {
            print "Authentication failure.  Use -s to pass in secret.\n";
            exit 1;
        }
        else {
            my $tty = IO::File->new( '/dev/tty', 'r+' );

            print $tty "Input secret:\n";
            my $secret = <$tty>;
            chomp($secret);

            $tty->close();

            send_copy_data( $data, $secret );
        }
    }

    $sock->close();
}
